import React, { useState, useEffect, useRef, useCallback } from 'react';

const TRANSLATIONS = {
  "en-US": {
    "title": "Circuit Flow",
    "inputPlaceholder": "Adjust the energy...",
    "updateButton": "Generate",
    "processingText": "Processing...",
  },
  "es-ES": {
    "title": "Flujo de Circuito",
    "inputPlaceholder": "Ajusta la energÃ­a...",
    "updateButton": "Generar",
    "processingText": "Procesando...",
  }
};

const appLocale = '{{APP_LOCALE}}';
const browserLocale = navigator.languages?.[0] || navigator.language || 'en-US';
const findMatchingLocale = (locale) => {
  if (TRANSLATIONS[locale]) return locale;
  const lang = locale.split('-')[0];
  const match = Object.keys(TRANSLATIONS).find(key => key.startsWith(lang + '-'));
  return match || 'en-US';
};
const locale = (appLocale !== '{{APP_LOCALE}}') ? findMatchingLocale(appLocale) : findMatchingLocale(browserLocale);
const t = (key) => TRANSLATIONS[locale]?.[key] || TRANSLATIONS['en-US'][key] || key;

const CircuitFlowVisualization = () => {
  const [energy, setEnergy] = useState(0.7);
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const timeRef = useRef(0);
  const pathsRef = useRef([]);
  const particlesRef = useRef([]);

  // Initialize circuit paths
  const initializePaths = useCallback((canvas) => {
    pathsRef.current = [];
    const numPaths = 40 + Math.floor(Math.random() * 20);
    
    for (let i = 0; i < numPaths; i++) {
      const path = {
        points: [],
        orientation: Math.random() > 0.5 ? 'horizontal' : 'vertical'
      };
      
      // Create circuit-like paths
      const segments = 3 + Math.floor(Math.random() * 5);
      let x = Math.random() * canvas.width;
      let y = Math.random() * canvas.height;
      
      path.points.push({ x, y });
      
      for (let j = 0; j < segments; j++) {
        const direction = Math.floor(Math.random() * 4); // 0=right, 1=down, 2=left, 3=up
        const length = 50 + Math.random() * 150;
        
        switch(direction) {
          case 0: x += length; break;
          case 1: y += length; break;
          case 2: x -= length; break;
          case 3: y -= length; break;
        }
        
        // Keep in bounds
        x = Math.max(50, Math.min(canvas.width - 50, x));
        y = Math.max(50, Math.min(canvas.height - 50, y));
        
        path.points.push({ x, y });
      }
      
      pathsRef.current.push(path);
    }
    
    // Initialize particles on paths
    particlesRef.current = [];
    const particlesPerPath = 3;
    
    pathsRef.current.forEach((path, pathIndex) => {
      for (let i = 0; i < particlesPerPath; i++) {
        particlesRef.current.push({
          pathIndex,
          segmentIndex: 0,
          progress: Math.random(),
          speed: 0.01 + Math.random() * 0.02,
          size: 2 + Math.random() * 2,
          flickerOffset: Math.random() * Math.PI * 2
        });
      }
    });
  }, []);

  // Animation loop
  const animate = useCallback((canvas, ctx) => {
    timeRef.current += 0.016;
    
    // Dark background
    ctx.fillStyle = 'rgba(5, 5, 10, 0.08)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Lines removed - only sparks visible
    
    // Update and draw particles
    particlesRef.current.forEach((particle) => {
      const path = pathsRef.current[particle.pathIndex];
      if (!path) return;
      
      // Update progress with speed spikes
      const speedSpike = Math.random() < 0.05 ? 2 + Math.random() * 3 : 1;
      particle.progress += particle.speed * energy * speedSpike;
      
      // Fade in and out
      particle.life = (particle.life || 0) + 0.02;
      const fadeIn = Math.min(particle.life * 2, 1);
      const fadeOut = particle.segmentIndex >= path.points.length - 2 ? 
        Math.max(0, 1 - (particle.progress * 2)) : 1;
      const fadeFactor = fadeIn * fadeOut;
      
      // Move to next segment if needed
      if (particle.progress >= 1) {
        particle.progress = 0;
        particle.segmentIndex++;
        
        // Loop back to start with new life cycle
        if (particle.segmentIndex >= path.points.length - 1) {
          particle.segmentIndex = 0;
          particle.life = 0;
          particle.speed = 0.01 + Math.random() * 0.02;
        }
      }
      
      // Get current position
      const p1 = path.points[particle.segmentIndex];
      const p2 = path.points[particle.segmentIndex + 1];
      
      if (!p1 || !p2) return;
      
      const x = p1.x + (p2.x - p1.x) * particle.progress;
      const y = p1.y + (p2.y - p1.y) * particle.progress;
      
      // Flicker effect - dimmer with fade
      const flicker = (Math.sin(timeRef.current * 8 + particle.flickerOffset) * 0.2 + 0.4) * fadeFactor;
      
      // Calculate direction of movement
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const angle = Math.atan2(dy, dx);
      
      // Add slight random drift for more organic movement
      const driftX = Math.sin(timeRef.current * 2 + particle.flickerOffset) * 3;
      const driftY = Math.cos(timeRef.current * 2 + particle.flickerOffset) * 3;
      const finalX = x + driftX;
      const finalY = y + driftY;
      
      // Draw spark trail - dimmer and more faded
      const trailLength = 15 + particle.size * 5;
      const trailStartX = finalX - Math.cos(angle) * trailLength;
      const trailStartY = finalY - Math.sin(angle) * trailLength;
      
      // Main spark line
      const gradient = ctx.createLinearGradient(trailStartX, trailStartY, finalX, finalY);
      gradient.addColorStop(0, 'rgba(218, 165, 32, 0)');
      gradient.addColorStop(0.5, `rgba(255, 200, 100, ${0.3 * flicker})`);
      gradient.addColorStop(1, `rgba(255, 255, 200, ${0.5 * flicker})`);
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(trailStartX, trailStartY);
      ctx.lineTo(finalX, finalY);
      ctx.stroke();
      
      // Add spark rays at the head - more subtle
      const numRays = 3;
      for (let i = 0; i < numRays; i++) {
        const rayAngle = angle + (Math.random() - 0.5) * Math.PI / 3;
        const rayLength = 3 + Math.random() * 6;
        const rayEndX = finalX + Math.cos(rayAngle) * rayLength;
        const rayEndY = finalY + Math.sin(rayAngle) * rayLength;
        
        ctx.beginPath();
        ctx.moveTo(finalX, finalY);
        ctx.lineTo(rayEndX, rayEndY);
        ctx.strokeStyle = `rgba(255, 255, 150, ${flicker * 0.4})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      // Bright head point - dimmer
      ctx.fillStyle = `rgba(255, 255, 200, ${flicker * 0.6})`;
      ctx.beginPath();
      ctx.arc(finalX, finalY, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Head glow - more subtle
      const glowGradient = ctx.createRadialGradient(finalX, finalY, 0, finalX, finalY, 8);
      glowGradient.addColorStop(0, `rgba(255, 255, 200, ${0.3 * flicker})`);
      glowGradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
      ctx.fillStyle = glowGradient;
      ctx.beginPath();
      ctx.arc(finalX, finalY, 8, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Pulse effects removed for cleaner look
    
    animationRef.current = requestAnimationFrame(() => animate(canvas, ctx));
  }, [energy]);

  // Handle canvas setup and animation
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initializePaths(canvas);
    };
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    animate(canvas, ctx);
    
    return () => {
      window.removeEventListener('resize', resizeCanvas);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [animate, initializePaths]);

  return (
    <div className="w-full h-screen relative overflow-hidden bg-black">
      <canvas
        ref={canvasRef}
        className="absolute inset-0"
      />
      
      <div className="absolute top-8 left-8 z-10">
        <h1 className="text-4xl font-light text-yellow-500 tracking-wide">{t('title')}</h1>
        <p className="text-sm text-yellow-500/60 mt-2">Electric signals flowing through invisible traces</p>
      </div>
      
      <div className="absolute bottom-8 left-1/2 transform -translate-x-1/2 z-10 w-96">
        <div className="bg-black/50 backdrop-blur-sm p-6 rounded-lg border border-yellow-600/30">
          <label className="block text-yellow-500 mb-2 text-sm">Current Flow</label>
          <input
            type="range"
            min="0.1"
            max="1"
            step="0.01"
            value={energy}
            onChange={(e) => setEnergy(parseFloat(e.target.value))}
            className="w-full"
          />
          <div className="text-yellow-500/80 text-center mt-2 text-sm">
            {Math.floor(energy * 100)}%
          </div>
        </div>
      </div>
    </div>
  );
};

export default CircuitFlowVisualization;