import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import Stripe from "stripe";
import { PrismaClient } from "@prisma/client";

dotenv.config();

const app = express();
const prisma = new PrismaClient();
const stripe = process.env.STRIPE_SECRET_KEY ? new Stripe(process.env.STRIPE_SECRET_KEY) : null;

app.use(cors());
app.use(express.json());

// ---------- helpers ----------
function signToken(payload) {
  return jwt.sign(payload, process.env.JWT_SECRET || "dev", { expiresIn: "7d" });
}

function auth(req, res, next) {
  const hdr = req.headers.authorization || "";
  const token = hdr.startsWith("Bearer ") ? hdr.slice(7) : null;
  if (!token) return res.status(401).json({ error: "No token" });
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET || "dev");
    next();
  } catch {
    return res.status(401).json({ error: "Invalid token" });
  }
}

// ---------- health ----------
app.get("/", (_, res) => res.json({ ok: true, service: "Smartflow Store API" }));

// ---------- auth ----------
app.post("/api/auth/signup", async (req, res) => {
  try {
    const { name, email, password, plan = "basic" } = req.body;
    if (!email || !password) return res.status(400).json({ error: "email and password required" });
    const exists = await prisma.user.findUnique({ where: { email } });
    if (exists) return res.status(409).json({ error: "email already in use" });
    const passwordHash = await bcrypt.hash(password, 10);
    const user = await prisma.user.create({ data: { name, email, passwordHash, plan } });
    const token = signToken({ id: user.id, email: user.email, plan: user.plan });
    res.json({ token, user: { id: user.id, email: user.email, name: user.name, plan: user.plan } });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "signup failed" });
  }
});

app.post("/api/auth/login", async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) return res.status(401).json({ error: "invalid credentials" });
    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(401).json({ error: "invalid credentials" });
    const token = signToken({ id: user.id, email: user.email, plan: user.plan });
    res.json({ token, user: { id: user.id, email: user.email, name: user.name, plan: user.plan } });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "login failed" });
  }
});

// ---------- stores ----------
app.post("/api/stores", auth, async (req, res) => {
  try {
    const { name, slug, theme = "default", branding = null } = req.body;
    // plan guard: basic = max 1 store, standard = up to 3
    const me = await prisma.user.findUnique({ where: { id: req.user.id }, include: { stores: true } });
    const limit = me.plan === "basic" ? 1 : me.plan === "standard" ? 3 : 999;
    if (me.stores.length >= limit) return res.status(403).json({ error: `store limit reached for plan ${me.plan}` });

    const store = await prisma.store.create({ data: { userId: req.user.id, name, slug, theme, branding } });
    res.json(store);
  } catch (e) {
    if (String(e.message).includes("Unique constraint")) return res.status(409).json({ error: "slug already taken" });
    console.error(e);
    res.status(500).json({ error: "create store failed" });
  }
});

app.get("/api/stores", auth, async (req, res) => {
  const stores = await prisma.store.findMany({ where: { userId: req.user.id } });
  res.json(stores);
});

// ---------- products ----------
app.post("/api/stores/:storeId/products", auth, async (req, res) => {
  try {
    const { storeId } = req.params;
    const { name, description = "", price, stock = 0, imageUrl = null } = req.body;

    // owner check
    const store = await prisma.store.findFirst({ where: { id: Number(storeId), userId: req.user.id } });
    if (!store) return res.status(404).json({ error: "store not found" });

    // plan guard: basic = max 10 products
    const me = await prisma.user.findUnique({ where: { id: req.user.id } });
    if (me.plan === "basic") {
      const count = await prisma.product.count({ where: { storeId: store.id } });
      if (count >= 10) return res.status(403).json({ error: "basic plan allows up to 10 products" });
    }

    const product = await prisma.product.create({
      data: { storeId: store.id, name, description, price, stock, imageUrl }
    });
    res.json(product);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "create product failed" });
  }
});

app.get("/api/stores/:storeId/products", async (req, res) => {
  const { storeId } = req.params;
  const products = await prisma.product.findMany({ where: { storeId: Number(storeId) } });
  res.json(products);
});

app.patch("/api/products/:id", auth, async (req, res) => {
  try {
    const { id } = req.params;
    // ensure owner
    const product = await prisma.product.findUnique({ where: { id: Number(id) }, include: { store: true } });
    if (!product || product.store.userId !== req.user.id) return res.status(404).json({ error: "product not found" });

    const updated = await prisma.product.update({ where: { id: product.id }, data: req.body });
    res.json(updated);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "update product failed" });
  }
});

app.delete("/api/products/:id", auth, async (req, res) => {
  try {
    const { id } = req.params;
    const product = await prisma.product.findUnique({ where: { id: Number(id) }, include: { store: true } });
    if (!product || product.store.userId !== req.user.id) return res.status(404).json({ error: "product not found" });

    await prisma.product.delete({ where: { id: product.id } });
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "delete product failed" });
  }
});

// ---------- orders (simple) ----------
app.post("/api/stores/:storeId/orders", async (req, res) => {
  try {
    const { storeId } = req.params;
    const { items } = req.body; // [{productId, quantity}]
    if (!Array.isArray(items) || items.length === 0) return res.status(400).json({ error: "no items" });

    // total
    const ids = items.map(it => it.productId);
    const dbProducts = await prisma.product.findMany({ where: { id: { in: ids }, storeId: Number(storeId) } });
    if (dbProducts.length !== ids.length) return res.status(400).json({ error: "invalid product(s)" });

    let total = 0;
    const orderItemsData = items.map(it => {
      const p = dbProducts.find(dp => dp.id === it.productId);
      total += p.price * it.quantity;
      return { productId: p.id, quantity: it.quantity, price: p.price };
    });

    const order = await prisma.order.create({
      data: {
        storeId: Number(storeId),
        totalAmount: total,
        paymentStatus: "pending",
        orderItems: { create: orderItemsData }
      },
      include: { orderItems: true }
    });

    res.json(order);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "create order failed" });
  }
});

app.get("/api/stores/:storeId/orders", auth, async (req, res) => {
  const { storeId } = req.params;
  // owner check
  const store = await prisma.store.findFirst({ where: { id: Number(storeId), userId: req.user.id } });
  if (!store) return res.status(404).json({ error: "store not found" });
  const orders = await prisma.order.findMany({ where: { storeId: store.id }, include: { orderItems: true } });
  res.json(orders);
});

// ---------- checkout (Stripe optional) ----------
app.post("/api/checkout/create-session", async (req, res) => {
  try {
    const { lineItems, successUrl, cancelUrl } = req.body;
    if (!stripe) {
      // Mock response if Stripe key not provided
      return res.json({ mock: true, url: successUrl || "http://localhost:3000/success" });
    }
    const session = await stripe.checkout.sessions.create({
      mode: "payment",
      line_items: lineItems, // [{ price_data: {currency, product_data: {name}, unit_amount}, quantity }]
      success_url: successUrl || "https://example.com/success",
      cancel_url: cancelUrl || "https://example.com/cancel"
    });
    res.json({ id: session.id, url: session.url });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "checkout session failed" });
  }
});

// ---------- error fallthrough ----------
app.use((err, _req, res, _next) => {
  console.error("Unhandled:", err);
  res.status(500).json({ error: "server error" });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, async () => {
  try {
    await prisma.$connect();
    console.log(`ðŸš€ Smartflow Store API running on http://localhost:${PORT}`);
  } catch (e) {
    console.error("DB connection failed:", e);
  }
});